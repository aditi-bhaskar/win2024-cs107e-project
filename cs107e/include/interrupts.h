#ifndef INTERRUPTS_H
#define INTERRUPTS_H

/*
 * Module to configure interrupts for Mango Pi.
 *
 * Author: Julie Zelenski <zelenski@cs.stanford.edu>
 */

#include <stdint.h>

/*
 * `interrupts_init`: Required initialization for interrupts
 *
 * Initialize interrupts and configures to a clean state.
 *
 *    - dispatch hanlder is installed at mtvec
 *    - all interrupt sources are disabled
 *    - interrupts are globally disabled
 *
 * This module init should be called once (and only once)
 * before any calls to other functions in the interrupts module.
 * Calling the init function a second time will raise an error.
 * Without more specific initialization semantics and structure,
 * this is the safe approach that avoids having to debug why a
 * source suddenly stopped receiving interrupts after a re-init
 * silently wiped the settings from previous configuration.
 */
void interrupts_init(void);

/*
 * `interrupts_global_enable`
 *
 * Turns on interrupts system-wide. An interrupt generated on
 * an interrupt source that is enabled will call the registered handler.
 */
void interrupts_global_enable(void);

/*
 * `interrupts_global_disable`
 *
 * Turns off interrupts system-wide. No interrupts will be generated.
 * Does not remove registered handlers or disable interrupt sources,
 * only temporarily suspends interrupt generation. Call
 * `interrupts_global_enable` to resume generating interrupts.
 */
void interrupts_global_disable(void);

/*
 * `handlerfn_t`
 *
 * This typedef gives a nickname to the type of function pointer used as
 * a handler callback. A handler is registered to an interrupt source. When
 * an interrupt is generated by that source, the handler is called to
 * process it. A handler takes two arguments. The first argument is the
 * value of the interrupted pc, the second is the client's
 * auxiliary data pointer (can be NULL if not used).
 */
typedef void (*handlerfn_t)(uintptr_t, void *);

/*
 * `interrupts_register_handler`
 *
 * Register the handler function for a given interrupt source. Each interrupt
 * source can have one handler: further dispatch should be invoked by
 * the handler itself.
 *
 * This function asserts on an attempt to register handler without initializing
 * the interrupts module (i.e. required to call `interrupts_init` first).
 *
 * An interrupt source is identified by number. Valid source numbers are
 * listed below in the `interrupt_source` enumeration.
 *
 * @param source    which interrupt source (see enumeration values below)
 * @param fn        handler function to call when interrupt generated on source
 * @param aux_data  client's data pointer to be passed as second argument
 *                  when calling handler function
 *
 * An assert is raised if `source` is invalid. `aux_data` can be NULL if
 * handler function has no need for auxiliary data.
 */
void interrupts_register_handler(int source, handlerfn_t fn, void *aux_data);

/*
 * `interrupts_remove_handler`
 *
 * Remove any handler previously registered for `source`.
 *
 * @param source    which interrupt source (see enumeration values below)
 *
 * An assert is raised if `source` is invalid.
 */
void interrupts_remove_handler(int source);

/*
 * Enumeration of valid interrupt sources
 *
 * Below are the interrupt sources that this module can enable, disable,
 * and handle.
 */
enum interrupt_source_t {
    INTERRUPT_SOURCE_UART0 = 18,
    INTERRUPT_SOURCE_UART1 = 19,
    INTERRUPT_SOURCE_UART2 = 20,
    INTERRUPT_SOURCE_UART3 = 21,
    INTERRUPT_SOURCE_UART4 = 22,
    INTERRUPT_SOURCE_UART5 = 23,
    INTERRUPT_SOURCE_HSTIMER0 = 71,
    INTERRUPT_SOURCE_HSTIMER1 = 72,
    INTERRUPT_SOURCE_GPIOB = 85,
    INTERRUPT_SOURCE_GPIOC = 87,
    INTERRUPT_SOURCE_GPIOD = 89,
    INTERRUPT_SOURCE_GPIOE = 91,
    INTERRUPT_SOURCE_GPIOF = 93,
    INTERRUPT_SOURCE_GPIOG = 95,
};

#endif
